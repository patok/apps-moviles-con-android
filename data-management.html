<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Desarrollo de Aplicaciones con Android - Seminario 2 (AUS)</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-background-video="video/android.mp4">
					<h1>Gestión de datos</h1>
					<h3>Seminario 2 - AUS</h3>
					<p>
						<small>Created by <a href="http://keilty.com.ar">Patricio Keilty</a> / <a href="http://twitter.com/patokeilty">@patokeilty</a></small>
					</p>
                    <p>
                        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
                            <img alt="Licencia Creative Commons" style="border-width:0" src="img/cc-by-nc-sa-88x31.png" />
                        </a>
                    </p>
				</section>

				<section>
					<h2>Gestión de datos - Opciones</h2>
					<p>Android provee distintas opciones a la hora de almacenar datos:
					<ul>
						<li>Shared Preferences (preferencias)</li>
						<li>almacenamiento interno (sistema de archivos)</li>
						<li>almacenamiento externo (sistema de archivos removible)</li>
						<li>base de datos SQLite</li>
					</ul>
				</section>

				<section>
					<h2>Preferencias</h2>
					<ul>
						<li class="fragment roll-in">permite a una aplicación almacenar y gestionar una cantidad mínima de datos
							primarios</li>
						<li class="fragment roll-in">almacén de pares clave-valor (clave: string, valor: float, int, string.</li>
						<li class="fragment roll-in">persistentes a la sesión de usuario,se almacena en el fs privado
							de la app, y se puede recuperar luego.</li>
						<li class="fragment roll-in">Típicamente se almacena datos particulares de usuario: credenciales, opciones de configuración como estilos, selección o activación de funcionalidad específica de la app, etc.</li>
					</ul>
					<p>ref: <strong><a
						href="http://developer.android.com/reference/android/content/SharedPreferences.html">SharedPreferences</a></strong>
		
				</section>

				<section>
					<section>
						<h2>Preferencias</h2>
						<p>Para obtener un objeto SharedPreferences la app utiliza uno de estos métodos:
				
						<ul>
							<li class="fragment fade-in"><a
									href="http://developer.android.com/reference/android/content/Context.html#getSharedPreferences(java.lang.String, int)">getSharedPreferences()</a>-
								usado para recuperar ficheros de preferencias identificados por nombre, especificado en el primer
								parámetro.</li>
							<li class="fragment fade-in"><a
									href="http://developer.android.com/reference/android/app/Activity.html#getPreferences(int)">getPreferences()</a>
								- para preferences exclusivas de Activity (no requiere proveer un nombre).</li>
						</ul>
					</section>
					<section>
						<h2>Preferencias ...</h2>
						<p class="fragment fade-in">luego de puede escribir mediante
				
						<ol>
							<li class="fragment fade-in">obtener un <a
									href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html">SharedPreferences.Editor</a>
								llamando a <a
									href="http://developer.android.com/reference/android/content/SharedPreferences.html#edit()">edit()</a>
							</li>
							<li class="fragment fade-in">setear valores con <a
									href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html#putBoolean(java.lang.String, boolean)">putBoolean()</a>
								o <a
									href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html#putString(java.lang.String, java.lang.String)">putString()</a>
							</li>
							<li class="fragment fade-in">persistir los valores con <a
									href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html#commit()">commit()</a>
							</li>
						</ol>
						<br /><br />
						<p class="fragment fade-in">para leer usa los métodos como <a
								href="http://developer.android.com/reference/android/content/SharedPreferences.html#getBoolean(java.lang.String, boolean)">getBoolean()</a>
							y <a
								href="http://developer.android.com/reference/android/content/SharedPreferences.html#getString(java.lang.String, java.lang.String)">getString()</a>
				
					</section>
				</section>

				<section>
					<h2>UI p/ Preferencias</h2>
					Android provee recursos de tipo Preference (definición .xml) y clase <strong>PreferenceActivity</strong> para
					facilitar su empleo
					<ol>
						<li class="fragment fade-in">crear un recurso de tipo Preferences, fichero de nombre prefs.xml</li>
						<li class="fragment fade-in">implementar un PrefsActivity que infle el fichero res prefs.xml</li>
						<li class="fragment fade-in">registrar la nueva PrefsActivity en AndroidManifest.xml</li>
						<li class="fragment fade-in">proveer una forma de invocar dicho activity (típicamente un menú)</li>
					</ol>
				</section>

				<section>
					<h2>SQLite</h2>
<p><strong>SQLite</strong> es una base de datos relacional embebida muy difundida, adoptada por Android. Emplea SQL standard 
<br/>Sus características mas sobresalientes son:
                        <ul>
                        <li class="fragment grow">cero configuración</li>
                        <li class="fragment grow">no tiene server: no hay proceso SQLite corriendo</li>
                        <li class="fragment grow">footprint reducido (&lt; 300KB)</li>
                        <li class="fragment grow">usa un único fichero de datos</li>
                        <li class="fragment grow">es de código abierto</li>
                        </ul>

				</section>

				<section>
					<h2>SQLite</h2><h3>SQLiteOpenHelper</h3>
<p>Android provee dentro de su API <strong><a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></strong> para simplificar la creación, upgrade y conexión a una base de datos SQLite.

				</section>

				<section>
			<h2>SQLiteOpenHelper</h2>
<p>La forma recomendada es crear un subclase de <strong><a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html">SQLiteOpenHelper</a></strong>, y redefinir onCreate() en el cual se ejecutan las sentencias SQL para creación de la bbdd.

<p><pre><code data-trim>
public class DictionaryOpenHelper extends SQLiteOpenHelper {

    private static final int DATABASE_VERSION = 2;
    private static final String DICTIONARY_TABLE_NAME = "dictionary";
    private static final String DICTIONARY_TABLE_CREATE =
                "CREATE TABLE " + DICTIONARY_TABLE_NAME + " (" +
                KEY_WORD + " TEXT, " +
                KEY_DEFINITION + " TEXT);";

    DictionaryOpenHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(DICTIONARY_TABLE_CREATE);
    }
}
</code></pre></p>


				</section>

				<section>
					<h2>SQLite</h2><h3>Migraciones y onUpgrade()</h3>
<p>Así como onCreate() se emplea para crear por única vez la bbdd, <a href="">onUpgrade()</a> se emplea para migrar de una versión a otra, es llamado cada vez que detecta un cambio en el nro de version de la base.<br/>
Entonces, típicamente vamos a ejecutar todos los <strong>CREATE TABLE</strong> en <strong>onCreate()</strong> para crear la base cuando no existe. En una app productiva, usaremos <strong>ALTER TABLE</strong> en el método <strong>onUpgrade()</strong> cuando hay cambios de esquema, lo cual es complejo.

				</section>


				<section>
					<h2>SQLite</h2><h3>Usando la bbdd</h3>

<p>Obtenemos un objeto <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html"><strong>SQLiteDatabase</strong></a> a partir del helper para read-only o read-write respectivamente invocando: 
                        <ul>
                        <li class="fragment grow"><a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getReadableDatabase()">getReadableDatabase()</a></li>
                        <li class="fragment grow"><a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase()">getWritableDatabase()</a></li>
                        </ul>

<p>una vez obtenido un objeto SQLiteDatabase se pueden emplear los métodos: insert(), update(), delete(), query()
				</section>

				<section>
					<h2>SQLite</h2><h3>Usando Cursor</h3>

<p>Cuando relizamos una consulta mediante alguna variación del método query() obtenemos un objeto <a href="http://developer.android.com/reference/android/database/Cursor.html"><strong>Cursor</strong></a>. Este permite acceso de lectura-escritura al set de resultados. 
				</section>


				<section>

					<h3>Inspeccionando una bbdd con el shell</h3>
<p><pre><code data-trim>
adb -s emulator-5554 shell
# sqlite3 /data/data/com.example.google.rss.rssexample/databases/rssitems.db
SQLite version 3.3.12
Enter ".help" for instructions
.... enter commands, then quit...
sqlite> .exit 
</code></pre></p>
				</section>

				<section>
					<h2>Usando ROOM</h2>
				
					<a href="https://developer.android.com/training/data-storage/room"><strong>Room</strong></a> es una herramienta que
					corre sobre SQLite3 , y permite una capa de abstracción, ocupándose de gran parte de las construcciones auxiliares
					como creación de la bbdd y tablas de c/ entidades, métodos de queries estándar.
				</section>

				<section>
					<h3>Usando ROOM</h3>
					<section>
						<ul>
							<li class="fragment roll-in">agregar dependencia libreria
								<pre><code data-trim>
																			...
																			def room_version = "1.1.1"
													
																			implementation "android.arch.persistence.room:runtime:$room_version"
																			annotationProcessor "android.arch.persistence.room:compiler:$room_version"
																			...
																		</code></pre>
							</li>
							<li class="fragment roll-in">componente @Database: clase abstracta extiende RoomDatabase, lista de
								entidades, método abstracto para recuperar los @DAO de c/ @Entity
								<pre><code data-trim>
																@Database(entities = {User.class}, version = 1)
																public abstract class AppDatabase extends RoomDatabase {
																	public abstract UserDao userDao();
																}
															</code></pre>
							</li>
						</ul>
					</section>
				
					<section>
						<ul>
							<li class="fragment roll-in">@Entity: representa una entidad, @PrimeryKey, @ColumnInfo, etc
								<pre><code data-trim>
																@Entity
																public class User {
																	@PrimaryKey
																	public int uid;
															
																	@ColumnInfo(name = "first_name")
																	public String firstName;
															
																	@ColumnInfo(name = "last_name")
																	public String lastName;
																}
															</code></pre>
							</li>
						</ul>
					</section>
					<section>
						<ul>
				
							<li class="fragment roll-in">@DAO: interface define los métodos para leer y escribir c/ @Entity: @Insert,
								@Update, @Delete, @Query
								<pre><code data-trim>
																@Dao
																public interface UserDao {
																	@Query("SELECT * FROM user")
																	List<User> getAll();
															
																	@Query("SELECT * FROM user WHERE uid IN (:userIds)")
																	List<User> loadAllByIds(int[] userIds);
															
																	@Query("SELECT * FROM user WHERE first_name LIKE :first AND " +
																		   "last_name LIKE :last LIMIT 1")
																	User findByName(String first, String last);
															
																	@Insert
																	void insertAll(User... users);
															
																	@Delete
																	void delete(User user);
																}
															</code></pre>
							</li>
						</ul>
					</section>
				
					<section>
						<ul>
							<li class="fragment roll-in">usar DatabaseBuilder para crear la bbdd
								<pre><code data-trim>
																AppDatabase db = Room.databaseBuilder(getApplicationContext(),
																AppDatabase.class, "database-name").build();
															</code></pre>
							</li>
						</ul>
					</section>
				
				</section>



			</div>

		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/zoom/zoom.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/search/search.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
			});

		</script>

	</body>
</html>
